// Utility generator
// Used to generate utilities & print utilities
@mixin generate-utility($utility, $infix, $is-rfs-media-query: false) {
    $values: map-get($utility, values);
  
    // If the values are a list or string, convert it into a map
    @if type-of($values) == "string" or type-of(nth($values, 1)) != "list" {
      $values: zip($values, $values);
    }
  
    @each $key, $value in $values {
      $properties: map-get($utility, property);
  
      // Multiple properties are possible, for example with vertical or horizontal margins or paddings
      @if type-of($properties) == "string" {
        $properties: append((), $properties);
      }
  
      // Use custom class if present
      $property-class: if(map-has-key($utility, class), map-get($utility, class), nth($properties, 1));
      $property-class: if($property-class == null, "", $property-class);
  
      // State params to generate pseudo-classes
      $state: if(map-has-key($utility, state), map-get($utility, state), ());
  
      $infix: if($property-class == "" and str-slice($infix, 1, 1) == "-", str-slice($infix, 2), $infix);
  
      // Don't prefix if value key is null (eg. with shadow class)
      $property-class-modifier: if($key, if($property-class == "" and $infix == "", "", "-") + $key, "");
  
      @if map-get($utility, rfs) {
        // Inside the media query
        @if $is-rfs-media-query {
          $val: rfs-value($value);
  
          // Do not render anything if fluid and non fluid values are the same
          $value: if($val == rfs-fluid-value($value), null, $val);
        }
        @else {
          $value: $value;
        }
      }
  
      $is-rtl: map-get($utility, rtl);
  
      @if $value != null {
        @if $is-rtl == false {
          /* rtl:begin:remove */
        }
        .#{$property-class + $infix + $property-class-modifier} {
          @each $property in $properties {
            #{$property}: $value if($enable-important-utilities, !important, null);
          }
        }
  
        @each $pseudo in $state {
          .#{$property-class + $infix + $property-class-modifier}-#{$pseudo}:#{$pseudo} {
            @each $property in $properties {
              #{$property}: $value if($enable-important-utilities, !important, null);
            }
          }
        }
        @if $is-rtl == false {
          /* rtl:end:remove */
        }
      }
    }
  }


// Media of at least the minimum breakpoint width. No query for the smallest breakpoint.
// Makes the @content apply to the given breakpoint and wider.
@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
    $min: breakpoint-min($name, $breakpoints);
    @if $min {
      @media (min-width: $min) {
        @content;
      }
    } @else {
      @content;
    }
  }
  

  // Framework grid generation
//
// Used only by Bootstrap to generate the correct number of grid classes given
// any value of `$grid-columns`.

@mixin make-grid-columns($columns: $grid-columns, $gutter: $grid-gutter-width, $breakpoints: $grid-breakpoints) {
    // Common properties for all breakpoints
    %grid-column {
    //   position: relative;
    //   width: 100%;
    //   padding-right: $gutter / 2;
    //   padding-left: $gutter / 2;
        float: left;
    }
  
    @each $breakpoint in map-keys($breakpoints) {
      $infix: breakpoint-infix($breakpoint, $breakpoints);
  
    //   @if $columns > 0 {
    //     // Allow columns to stretch full width below their breakpoints
    //     @for $i from 1 through $columns {
    //       .col#{$infix}-#{$i} {
    //         @extend %grid-column;
    //       }
    //     }
    //   }
  
    //   .col#{$infix},
    //   .col#{$infix}-auto {
    //     @extend %grid-column;
    //   }
  
      @include media-breakpoint-up($breakpoint, $breakpoints) {
        // Provide basic `.col-{bp}` classes for equal-width flexbox columns
        // .col#{$infix} {
        //   flex-basis: 0;
        //   flex-grow: 1;
        //   max-width: 100%;
        // }
  
        // @if $grid-row-columns > 0 {
        //   @for $i from 1 through $grid-row-columns {
        //     .row-cols#{$infix}-#{$i} {
        //       @include row-cols($i);
        //     }
        //   }
        // }
  
        // .col#{$infix}-auto {
        //   @include make-col-auto();
        // }
        
  // code chạy class col- kèm mediaquery

        // @if $columns > 0 {
        //   @for $i from 1 through $columns {
        //     .col#{$infix}-#{$i} {
        //       @include make-col($i, $columns);
        //     }
        //   }
        // }
  
        // .order#{$infix}-first { order: -1; }
  
        // .order#{$infix}-last { order: $columns + 1; }
  
        // @for $i from 0 through $columns {
        //   .order#{$infix}-#{$i} { order: $i; }
        // }
  
        // @if $columns > 0 {
        //   // `$columns - 1` because offsetting by the width of an entire row isn't possible
        //   @for $i from 0 through ($columns - 1) {
        //     @if not ($infix == "" and $i == 0) { // Avoid emitting useless .offset-0
        //       .offset#{$infix}-#{$i} {
        //         @include make-col-offset($i, $columns);
        //       }
        //     }
        //   }
        // }
      }
    }
  }
  

  /// Grid system
//
// Generate semantic grid columns with these mixins.

@mixin make-container($gutter: $grid-gutter-width) {
    width: 100%;
    padding-right: $gutter / 2;
    padding-left: $gutter / 2;
    margin-right: auto;
    margin-left: auto;
}
  
  @mixin make-row($gutter: $grid-gutter-width) {
    overflow: hidden;
  }
  
  // For each breakpoint, define the maximum width of the container in a media query
  @mixin make-container-max-widths($max-widths: $container-max-widths, $breakpoints: $grid-breakpoints) {
    @each $breakpoint, $container-max-width in $max-widths {
      @include media-breakpoint-up($breakpoint, $breakpoints) {
        max-width: $container-max-width;
      }
    }
    @include deprecate("The `make-container-max-widths` mixin", "v4.5.2", "v5");
  }
  
  @mixin make-col-ready($gutter: $grid-gutter-width) {
    position: relative;
    // Prevent columns from becoming too narrow when at smaller grid tiers by
    // always setting `width: 100%;`. This works because we use `flex` values
    // later on to override this initial width.
    width: 100%;
    padding-right: $gutter / 2;
    padding-left: $gutter / 2;
  }
  
  @mixin make-col($size, $columns: $grid-columns) {
    // flex: 0 0 percentage($size / $columns);
    // Add a `max-width` to ensure content within each column does not blow out
    // the width of the column. Applies to IE10+ and Firefox. Chrome and Safari
    // do not appear to require this.
    width: percentage($size / $columns);
    float: left;
  }
  
  @mixin make-col-auto() {
    flex: 0 0 auto;
    width: auto;
    max-width: 100%; // Reset earlier grid tiers
  }
  
  @mixin make-col-offset($size, $columns: $grid-columns) {
    $num: $size / $columns;
    margin-left: if($num == 0, 0, percentage($num));
  }
  
  // Row columns
  //
  // Specify on a parent element(e.g., .row) to force immediate children into NN
  // numberof columns. Supports wrapping to new lines, but does not do a Masonry
  // style grid.
  @mixin row-cols($count) {
    > * {
      flex: 0 0 100% / $count;
      max-width: 100% / $count;
    }
  }
  

  // scss-docs-start table-variant
@mixin table-variant($state, $background) {
  .table-#{$state} {
    $color: color-contrast(opaque($body-bg, $background));
    $hover-bg: mix($color, $background, percentage($table-hover-bg-factor));
    $striped-bg: mix($color, $background, percentage($table-striped-bg-factor));
    $active-bg: mix($color, $background, percentage($table-active-bg-factor));

    --#{$variable-prefix}table-bg: #{$background};
    --#{$variable-prefix}table-striped-bg: #{$striped-bg};
    --#{$variable-prefix}table-striped-color: #{color-contrast($striped-bg)};
    --#{$variable-prefix}table-active-bg: #{$active-bg};
    --#{$variable-prefix}table-active-color: #{color-contrast($active-bg)};
    --#{$variable-prefix}table-hover-bg: #{$hover-bg};
    --#{$variable-prefix}table-hover-color: #{color-contrast($hover-bg)};

    color: $color;
    border-color: mix($color, $background, percentage($table-border-factor));
  }
}
// scss-docs-end table-variant